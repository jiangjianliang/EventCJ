definition
module languages/aspectj/abc/Keyword[JavaCtx AspectCtx PointcutCtx PatternCtx]
imports
  languages/java/JavaMix[PlainJavaTheCtx]

exports

  %%%
   %% Keywords in Java Context
   %%%
  lexical syntax
      "privileged"
    | "aspect"
    | "pointcut"
      -> Keyword[[JavaCtx]]

  %%%
   %% Keywords in Aspect Context
   %%%
  lexical syntax
      "after"
    | "around"
    | "before"
    | "declare"
    | "issingleton"
    | "percflow"
    | "percflowbelow"
    | "pertarget"
    | "perthis"
    | "pointcut"
    | "proceed"
      -> Keyword[[AspectCtx]]

    Keyword[[JavaCtx]] -> Keyword[[AspectCtx]]

  %%%
   %% Keywords in Pointcut Context
   %%%
  lexical syntax
    PrimPointcutName   -> Keyword[[PointcutCtx]]
    Keyword[[JavaCtx]] -> Keyword[[PointcutCtx]]

      "error"
    | "parents"
    | "precedence"
    | "returning"
    | "soft"
    | "throwing"
    | "warning" ->  Keyword[[PointcutCtx]]

  %%%
   %% Keywords in Pattern Context
   %%%
  lexical syntax
    Keyword[[PointcutCtx]] -> Keyword[[PatternCtx]]
    Keyword[[PatternCtx]] -> IdPattern {reject}

  context-free syntax
    "proceed" -> MethodSpec[[AspectCtx]] {cons("Proceed")}

module languages/aspectj/pointcut/Expression[Ctx JavaCtx]
imports
  languages/aspectj/common/BooleanComposition[PointcutExpr]

exports
  sorts PointcutExpr PrimPointcutName
  context-free syntax
    "call"      "(" MethodConstrPattern ")" -> PointcutExpr {cons("Call")}
    "execution" "(" MethodConstrPattern ")" -> PointcutExpr {cons("Exec")}
  lexical syntax
    "call" | "execution" -> PrimPointcutName

  context-free syntax
    "initialization"       "(" ConstrPattern ")"    -> PointcutExpr {cons("InitExec")}
    "preinitialization"    "(" ConstrPattern ")"    -> PointcutExpr {cons("PreInitExec")}
    "staticinitialization" "(" TopTypePattern ")" -> PointcutExpr {cons("StaticInitExec")}
  lexical syntax
    "initialization" | "preinitialization" | "staticinitialization" -> PrimPointcutName

  context-free syntax
    "get" "(" FieldPattern ")" -> PointcutExpr {cons("GetField")}
    "set" "(" FieldPattern ")" -> PointcutExpr {cons("SetField")}
  lexical syntax
    "get" | "set" -> PrimPointcutName

  context-free syntax
    "handler" "(" TopTypePattern ")" -> PointcutExpr {cons("Handler")}
  lexical syntax
    "handler" -> PrimPointcutName

  context-free syntax
    "adviceexecution" "(" ")" -> PointcutExpr {cons("AdviceExec")}
  lexical syntax
    "adviceexecution" -> PrimPointcutName

  context-free syntax
    "within"     "(" TopTypePattern ")" -> PointcutExpr {cons("Within")}
    "withincode" "(" MethodConstrPattern ")" -> PointcutExpr {cons("WithinCode")}
  lexical syntax
    "within" | "withincode" -> PrimPointcutName

  context-free syntax
    "cflow"      "(" PointcutExpr ")" -> PointcutExpr {cons("CFlow")}
    "cflowbelow" "(" PointcutExpr ")" -> PointcutExpr {cons("CFlowBelow")}
  lexical syntax
    "cflow" | "cflowbelow" -> PrimPointcutName

  context-free syntax
    "if" "(" Expr[[JavaCtx]] ")" -> PointcutExpr {cons("If")}
  lexical syntax
    "if" -> PrimPointcutName

  context-free syntax
    "this"    "("  TypeOrIdPattern       ")" -> PointcutExpr {cons("This")}
    "target"  "("  TypeOrIdPattern       ")" -> PointcutExpr {cons("Target")}
    "args"    "(" {TypeOrIdPattern ","}* ")" -> PointcutExpr {cons("Args")}
   
  lexical syntax
    "this" | "target" | "args" -> PrimPointcutName

  context-free syntax    
    "@this"       "(" AnnoOrId ")" -> PointcutExpr {cons("AtThis")}
    "@target"     "(" AnnoOrId ")" -> PointcutExpr {cons("AtTarget")}
    "@within"     "(" AnnoOrId ")" -> PointcutExpr {cons("AtWithin")}
    "@withincode" "(" AnnoOrId ")" -> PointcutExpr {cons("AtWithinCode")}
    "@annotation" "(" AnnoOrId ")" -> PointcutExpr {cons("AtAnno")}
    "@args" "(" {AnnoOrIdPattern ","}* ")" -> PointcutExpr {cons("AtArgs")}
   
  context-free syntax
    PointcutName "(" {TypeOrIdPattern ","}* ")" -> PointcutExpr {cons("NamedPointcut")}

  sorts PointcutName
  context-free syntax
    Id[[Ctx]]                                 -> PointcutName {cons("PointcutName")}
    ClassOrInterfaceType[[Ctx]] "." Id[[Ctx]] -> PointcutName {cons("PointcutName")}

  sorts AnnoOrId AnnoOrIdPattern TypeOrIdPattern
  context-free syntax
    TypeName[[Ctx]] -> AnnoOrId
    "*"      -> AnnoOrIdPattern {cons("Wildcard")}
    ".."     -> AnnoOrIdPattern {cons("DotWildcard")}
    AnnoOrId -> AnnoOrIdPattern
 
    "*"             -> TypeOrIdPattern {cons("Wildcard")}
    ".."            -> TypeOrIdPattern {cons("DotWildcard")}
    Type[[Ctx]]     -> TypeOrIdPattern
    Type[[Ctx]] "+" -> TypeOrIdPattern {cons("Subtype")}


  lexical restrictions
    "adviceexecution"
    "args"
    "call"
    "cflow"
    "cflowbelow"
    "error"
    "execution"
    "get"
    "handler"
    "initialization"
    "parents"
    "precedence"
    "preinitialization"
    "returning"
    "set"
    "soft"
    "staticinitialization"
    "target"
    "throwing"
    "warning"
    "within"
    "withincode"
      -/- [A-Za-z0-9\_\$]

module languages/aspectj/pointcut/Declaration[Ctx]
exports
  sorts
    PointcutDec
    PointcutDecBody
    PointcutDecHead

  context-free syntax
    PointcutDecHead PointcutBody -> PointcutDec {cons("PointcutDec")}

    %%%
     %% @todo What modifiers are allowed for a pointcut?
     %%%
    (Anno[[Ctx]] | Modifier[[Ctx]])* "pointcut" Id[[Ctx]] "(" {FormalParam[[Ctx]] ","}* ")"
      -> PointcutDecHead {cons("PointcutDecHead")}

    ":" PointcutExpr ";" -> PointcutBody {cons("PointcutBody")}
                     ";" -> PointcutBody {cons("NoPointcutBody")}

module languages/aspectj/pattern/Annotation[Ctx]
exports
  sorts
    AnnoPattern
    SimpleAnnoPattern

  context-free syntax
    "@" "(" TypePattern ")" -> SimpleAnnoPattern {cons("SimpleAnnoPattern")}
    "@" TypeName[[Ctx]]     -> SimpleAnnoPattern {cons("SimpleAnnoPatternExact")}
    "!" SimpleAnnoPattern   -> NotSimpleAnnoPattern {cons("Not")}

    (SimpleAnnoPattern | NotSimpleAnnoPattern)* -> AnnoPattern {cons("AnnoPattern")}
    (SimpleAnnoPattern | NotSimpleAnnoPattern)+ -> AnnoPatternPlus {cons("AnnoPattern")}

module languages/aspectj/pattern/Type[Ctx]
imports
  languages/aspectj/common/BooleanComposition[TypePattern]
  languages/aspectj/pattern/Name[Ctx]
  languages/java/JavaMix[PlainJavaTheCtx]

exports
  sorts
    TopTypePattern      
    TypePattern
    TypeParamsPattern
    TypeParamPattern
    TypeBoundPattern
    
  context-free syntax
    TypeDecSpecPattern -> BaseTypePattern {cons("RefTypePattern")}
    PrimType[[Ctx]]    -> BaseTypePattern {cons("PrimTypePattern")}

    BaseTypePattern  -> TypePattern
    "void"           -> TypePattern {cons("Void")}
    TypePattern "[]" -> TypePattern {cons("ArrayType")}
    "?"              -> TypePattern {cons("Wildcard")}

  context-free syntax
    NamePattern     -> TypeDecSpecPattern
    NamePattern "+" -> TypeDecSpecPattern {cons("Subtype")}

    TypeDecSpecPattern TypeParamsPattern -> TypePattern {cons("GenericTypePattern")}
    NamePattern        TypeParamsPattern "+" -> TypePattern {cons("GenericSubtypePattern")}

    "(" AnnoPatternPlus TypePattern ")" -> TypePattern {cons("AnnoTypePattern")}

    AnnoPatternPlus TypePattern -> TopTypePattern {cons("AnnoTypePattern")}
    TypePattern                 -> TopTypePattern

  context-free syntax

  context-free syntax
    TypePattern TypeBoundPattern?      -> TypeParamPattern  {cons("TypeParam")}
    "<" {TypeParamPattern ","}+ ">"    -> TypeParamsPattern {cons("TypeParams")}
    
    "extends" {TypePattern "&"}+       -> TypeBoundPattern  {cons("WildcardUpperBound")}
    "super"   {TypePattern "&"}+       -> TypeBoundPattern  {cons("WildcardLowerBound")}

  %%%
   %% Void, int are valid name patterns, so they should be reject as type patterns.
   %%%
  context-free syntax
    Keyword[[PlainJavaTheCtx]] -> TypeDecSpecPattern {reject}

module languages/aspectj/pattern/Name[Ctx]
exports
  sorts NamePattern
  context-free syntax
    IdPattern                  -> NamePattern {cons("NamePattern")}
    NamePattern "."  IdPattern -> NamePattern {cons("NamePattern")} 
    NamePattern ".." IdPattern -> NamePattern {cons("WildcardNamePattern")} 

  sorts IdPattern
  lexical syntax	
    [a-zA-Z\_\$\*][a-zA-Z0-9\_\$\*]* -> IdPattern

  lexical restrictions 	 
    IdPattern -/- [a-zA-Z0-9\_\$\*]

module languages/aspectj/pattern/FormalParameter[Ctx]
exports

  %% @todo The FormalWildcard could produce a list. Does implode allow this?
  sorts FormalParam
  context-free syntax
    ".."              -> FormalPattern {cons("FormalWildcard")}
    TypePattern       -> FormalPattern
    TypePattern "..." -> FormalPattern {cons("VarArityParamPattern")}

module languages/aspectj/common/BooleanComposition[E]
exports
  context-free syntax
    "(" E ")" -> E {bracket}
    "!" E     -> E {cons("NotComp")}
    E "&&" E  -> E {left, cons("AndComp")}
    E "||" E  -> E {left, cons("OrComp")}

  context-free priorities
    "!" E    -> E
  > E "&&" E -> E
  > E "||" E -> E


module languages/aspectj/pattern/ClassName[Ctx]
imports
  languages/aspectj/common/BooleanComposition[ClassNamePattern]

exports
  sorts ClassNamePattern
  context-free syntax
    NamePattern                   -> ClassNamePattern {cons("SimpleNamePattern")}
    NamePattern TypeParamsPattern -> ClassNamePattern {cons("Generic")}

    NamePattern "+"                   -> ClassNamePattern {cons("Subtype")}
    NamePattern "+" TypeParamsPattern -> ClassNamePattern {cons("Subtype")}
    NamePattern TypeParamsPattern "+" -> ClassNamePattern {cons("Subtype")}

module languages/aspectj/pattern/ClassMember[Ctx]
imports
  languages/aspectj/pattern/ClassName[Ctx]
  languages/aspectj/pattern/FormalParameter[Ctx]
  languages/aspectj/pattern/Type[Ctx]

exports
  sorts
    MethodConstrPattern
    MethodPattern
    ConstrPattern

  context-free syntax
    AnnoPattern MethodModPattern TypePattern ClassMemberNamePattern "(" {FormalPattern ","}* ")" ThrowsPattern? -> MethodPattern {cons("MethodPattern")}
    AnnoPattern ConstrModPattern             ConstrNamePattern      "(" {FormalPattern ","}* ")" ThrowsPattern? -> ConstrPattern {cons("ConstrPattern")}

    MethodPattern -> MethodConstrPattern
    ConstrPattern -> MethodConstrPattern

  sorts FieldPattern
  context-free syntax
    AnnoPattern FieldModPattern TypePattern ClassMemberNamePattern -> FieldPattern {cons("FieldPattern")}

  %%%
   %% @todo Parenthesized type pattern
   %%%
  sorts
    ClassMemberNamePattern
    ConstrNamePattern
  context-free syntax
                     IdPattern -> ClassMemberNamePattern {cons("MemberName")}
    TypePattern "."  IdPattern -> ClassMemberNamePattern {cons("MemberName")}
    TypePattern ".." IdPattern -> ClassMemberNamePattern {cons("WildcardMemberName")}

                     "new" -> ConstrNamePattern      {cons("ConstrName")}
    TypePattern "."  "new" -> ConstrNamePattern      {cons("ConstrName")}
    TypePattern ".." "new" -> ConstrNamePattern      {cons("WildcardConstrName")}

  sorts
    MethodModPattern
    ConstrModPattern
    FieldModPattern
  context-free syntax
    "!" MethodMod[[Ctx]] -> NotMethodMod {cons("Not")}
    "!" FieldMod[[Ctx]]  -> NotFieldMod  {cons("Not")}
    "!" ConstrMod[[Ctx]] -> NotConstrMod {cons("Not")}

    (MethodMod[[Ctx]] | NotMethodMod)* -> MethodModPattern {cons("ModPattern")}
    (ConstrMod[[Ctx]] | NotConstrMod)* -> ConstrModPattern {cons("ModPattern")}
    (FieldMod[[Ctx]]  | NotFieldMod )* -> FieldModPattern  {cons("ModPattern")}

  sorts ThrowsPattern ExceptionPattern
  context-free syntax
    "throws" {ExceptionPattern ","}+ -> ThrowsPattern {cons("ThrowsPattern")}

    %% a top-level not binds weaker than other nots.
    "!" ClassNamePattern -> ExceptionPattern {cons("NotThrowsCondition"), prefer}
    ClassNamePattern     -> ExceptionPattern {cons("ThrowsCondition")}

  sorts ElementPattern
  context-free syntax
    MethodConstrPattern -> ElementPattern
            TypePattern -> ElementPattern
           FieldPattern -> ElementPattern
    


module languages/aspectj/pattern/Main[Ctx]
imports
  languages/aspectj/pattern/ClassMember[Ctx]
  languages/aspectj/pattern/ClassName[Ctx]
  languages/aspectj/pattern/FormalParameter[Ctx]
  languages/aspectj/pattern/Name[Ctx]
  languages/aspectj/pattern/Type[Ctx]
  languages/aspectj/pattern/Annotation[Ctx]


module languages/aspectj/aspect/IntertypeMemberDeclaration[Ctx]
exports
  sorts IntertypeMemberDec

  %%%
   %% Intertype method declaration
   %%%
  context-free syntax
    IntertypeMethodDecHead MethodBody[[Ctx]] -> IntertypeMemberDec {cons("IntertypeMethodDec")}

    (Anno[[Ctx]] | MethodMod[[Ctx]])* TypeParams[[Ctx]]? ResultType[[Ctx]]
      TypeName[[Ctx]] TypeParams[[Ctx]]? "." Id[[Ctx]] "(" {FormalParam[[Ctx]] ","}* ")" Throws[[Ctx]]?
      -> IntertypeMethodDecHead {cons("IntertypeMethodDecHead")}

  %%%
   %% Intertype constructor declaration
   %%%
  context-free syntax
    IntertypeConstrDecHead ConstrBody[[Ctx]] -> IntertypeMemberDec {cons("IntertypeConstrDec")}

    (Anno[[Ctx]] | ConstrMod[[Ctx]])* TypeParams[[Ctx]]?
      TypeName[[Ctx]] TypeParams[[Ctx]]? "."
      "new" "(" {FormalParam[[Ctx]] ","}* ")" Throws[[Ctx]]?
      -> IntertypeConstrDecHead {cons("IntertypeConstrDecHead")}

  %%%
   %% Intertype field declaration
   %%
   %% @todo This will allow dimensions after the identifier, which is not
   %%        supported by AspectJ.
   %%%
  context-free syntax
    (Anno[[Ctx]] | FieldMod[[Ctx]])* Type[[Ctx]] TypeName[[Ctx]] TypeParams[[Ctx]]? "." VarDec[[Ctx]] ";"
      -> IntertypeMemberDec {cons("IntertypeFieldDec")}

module languages/aspectj/aspect/AdviceDeclaration[Ctx]
exports
  sorts AdviceDec AdviceMod
  context-free syntax
    AdviceMod* AdviceSpec Throws[[Ctx]]? ":" PointcutExpr MethodBody[[Ctx]] -> AdviceDec {cons("AdviceDec")}

    StrictFP[[Ctx]] -> AdviceMod
    Anno[[Ctx]]     -> AdviceMod

  sorts AdviceSpec
  context-free syntax
    "before" "(" {FormalParam[[Ctx]] ","}* ")"             -> AdviceSpec {cons("Before")}
    "after"  "(" {FormalParam[[Ctx]] ","}* ")" ExitStatus? -> AdviceSpec {cons("After")}

    ResultType[[Ctx]] "around" "(" {FormalParam[[Ctx]] ","}* ")" -> AdviceSpec {cons("Around")}

    "returning"                            -> ExitStatus {cons("Returning")}
    "returning" "("                    ")" -> ExitStatus {cons("Returning")}
    "returning" "(" FormalParam[[Ctx]] ")" -> ExitStatus {cons("Returning")}

    "throwing"                             -> ExitStatus {cons("Throwing")}
    "throwing"  "("                    ")" -> ExitStatus {cons("Throwing")}
    "throwing"  "(" FormalParam[[Ctx]] ")" -> ExitStatus {cons("Throwing")}

module languages/aspectj/aspect/DeclareDeclaration[Ctx PointcutCtx]
exports
  sorts DeclareDec
  context-free syntax
    Anno[[Ctx]]* "declare" "parents" ":" TopTypePattern Parent ";"
      -> DeclareDec {cons("DecParent")}

    Anno[[Ctx]]* "declare" "warning" ":" PointcutExpr ":" StringLiteral[[PointcutCtx]] ";"
      -> DeclareDec {cons("DecWarning")}

    Anno[[Ctx]]* "declare" "error" ":" PointcutExpr ":" StringLiteral[[PointcutCtx]] ";"
      -> DeclareDec {cons("DecError")}

    Anno[[Ctx]]* "declare" "soft" ":" Type[[PointcutCtx]] ":" PointcutExpr ";"
      -> DeclareDec {cons("DecSoft")}
      
    %% Strange parenthesis in ajc testsuite ....
    Anno[[Ctx]]* "declare" "soft" ":" "(" Type[[PointcutCtx]] ")" ":" PointcutExpr ";"
      -> DeclareDec {cons("DecSoft")}

    Anno[[Ctx]]* "declare" "precedence" ":" {TopTypePattern ","}+ ";"
      -> DeclareDec {cons("DecPrecedence")}

    Anno[[Ctx]]* "declare" AnnoDeclKind ":" ElementPattern ":" Anno[[AspectCtx]] ";"
      -> DeclareDec {cons("DecAnno")}

  sorts AnnoDeclKind
  context-free syntax
           "@type" -> AnnoDeclKind {cons("DecAnnoType")}
    "@constructor" -> AnnoDeclKind {cons("DecAnnoConstructor")}
         "@method" -> AnnoDeclKind {cons("DecAnnoMethod")}
          "@field" -> AnnoDeclKind {cons("DecAnnoField")}

  sorts Parent
  context-free syntax
    Super[[PointcutCtx]]             -> Parent
    Interfaces[[PointcutCtx]]        -> Parent
    
    %%%
     %% Undocumented feature (AspectJ guide) : add interfaces with extends.
     %%%
    ExtendsInterfaces[[PointcutCtx]] -> Parent {avoid}

module languages/aspectj/aspect/BodyDeclaration[Ctx]
imports
  languages/aspectj/aspect/DeclareDeclaration[Ctx]
  languages/aspectj/aspect/AdviceDeclaration[Ctx]
  languages/aspectj/aspect/IntertypeMemberDeclaration[Ctx]

exports
  sorts AspectBodyDec
  context-free syntax
    ClassBodyDec[[Ctx]] -> AspectBodyDec
    DeclareDec          -> AspectBodyDec 
    AdviceDec           -> AspectBodyDec
    IntertypeMemberDec  -> AspectBodyDec

    AspectDec           -> ClassMemberDec[[Ctx]]
    PointcutDec         -> ClassMemberDec[[Ctx]]


module languages/aspectj/aspect/Declaration[Ctx JavaCtx]
imports
  languages/aspectj/aspect/BodyDeclaration[Ctx]

exports
  sorts AspectDec
  context-free syntax
    AspectDecHead AspectBody -> AspectDec {cons("AspectDec")}

    (Anno[[Ctx]] | AspectMod)* "aspect" Id[[Ctx]] TypeParams[[Ctx]]? Super[[Ctx]]? Interfaces[[Ctx]]? PerClause?
      -> AspectDecHead {cons("AspectDecHead")}

  sorts PerClause
  context-free syntax
    "pertarget"     "(" PointcutExpr ")" -> PerClause {cons("PerTarget")}
    "perthis"       "(" PointcutExpr ")" -> PerClause {cons("PerThis")}
    "percflow"      "(" PointcutExpr ")" -> PerClause {cons("PerCFlow")}
    "percflowbelow" "(" PointcutExpr ")" -> PerClause {cons("PerCFlowBelow")}
    "pertypewithin" "(" TypePattern ")"  -> PerClause {cons("PerTypeWithin")}
    "issingleton"                        -> PerClause {cons("IsSingleton")}
    "issingleton" "(" ")"                -> PerClause {cons("IsSingleton")}

  sorts AspectBody
  context-free syntax
    "{" AspectBodyDec* "}" -> AspectBody {cons("AspectBody")}

  %% todo: which modifiers are allowed?
  sorts AspectMod
  context-free syntax
    ClassMod[[JavaCtx]] -> AspectMod
    "privileged"        -> AspectMod {cons("Privileged")}

module languages/aspectj/lexical/Keyword
exports
  lexical restrictions
    "privileged"
    "aspect"
    "after"
    "around"
    "before"
    "declare"
    "issingleton"
    "percflow"
    "percflowbelow"
    "pertarget"
    "perthis"
    "pointcut"
      -/- [A-Za-z0-9\_\$]

module languages/java-15/expressions/Priorities
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/expressions/Main

exports
  context-free priorities
      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
    > {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      } 

  context-free priorities
      {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      }
    > { "(" PrimType ")" Expr -> Expr    
        "(" RefType  ")" Expr -> Expr
      }

  context-free priorities
      "(" PrimType ")" Expr -> Expr
    > {left:
        Expr "*" Expr -> Expr
        Expr "/" Expr -> Expr
        Expr "%" Expr -> Expr
      } 

  context-free priorities
      "(" RefType ")" Expr -> Expr 
    > {
        "++" Expr -> Expr
        "--" Expr -> Expr
        "+"  Expr -> Expr
        "-"  Expr -> Expr
      }

  context-free priorities
    {
      Expr ArraySubscript -> ArrayAccess
      Expr "." Id -> FieldAccess
      Expr "." TypeArgs? Id -> MethodSpec
    }
  > {right:
      Expr "++" -> Expr
      Expr "--" -> Expr
    }
  > {
      "++" Expr -> Expr
      "--" Expr -> Expr
      "+"  Expr -> Expr
      "-"  Expr -> Expr
      "~"  Expr -> Expr
      "!"  Expr -> Expr
    }
  > {left:
      Expr "*" Expr -> Expr
      Expr "/" Expr -> Expr
      Expr "%" Expr -> Expr
    } 
  > {left:
      Expr "+" Expr -> Expr
      Expr "-" Expr -> Expr
    }
  > {left:
      Expr "<<"  Expr -> Expr
      Expr ">>"  Expr -> Expr
      Expr ">>>" Expr -> Expr
    }
  > {left:
      Expr "instanceof" RefType -> Expr
      Expr "<"   Expr -> Expr
      Expr ">"   Expr -> Expr
      Expr "<="  Expr -> Expr
      Expr ">="  Expr -> Expr
    }
  > {left:
      Expr "=="  Expr -> Expr
      Expr "!="  Expr -> Expr
    }
  >   Expr "&"   Expr -> Expr
  >   Expr "^"   Expr -> Expr
  >   Expr "|"   Expr -> Expr
  >   Expr "&&"  Expr -> Expr
  >   Expr "||"  Expr -> Expr
  >   Expr CondMid Expr -> Expr
  > {right:
      LHS "="    Expr -> Expr
      LHS "*="   Expr -> Expr
      LHS "/="   Expr -> Expr
      LHS "%="   Expr -> Expr
      LHS "+="   Expr -> Expr
      LHS "-="   Expr -> Expr
      LHS "<<="  Expr -> Expr
      LHS ">>="  Expr -> Expr
      LHS ">>>=" Expr -> Expr
      LHS "&="   Expr -> Expr
      LHS "^="   Expr -> Expr
      LHS "|="   Expr -> Expr
    }

module languages/java-15/expressions/Restrictions
exports
  lexical restrictions
    "+" -/- [\+]
    "-" -/- [\-]
    "/" -/- [\/]

module languages/java-15/expressions/AssignmentOperators
imports
  languages/java-15/expressions/Main

exports
  sorts LHS
  context-free syntax
    LHS "="    Expr -> Expr {cons("Assign")}
    LHS "*="   Expr -> Expr {cons("AssignMul")}
    LHS "/="   Expr -> Expr {cons("AssignDiv")}
    LHS "%="   Expr -> Expr {cons("AssignRemain")}
    LHS "+="   Expr -> Expr {cons("AssignPlus")}
    LHS "-="   Expr -> Expr {cons("AssignMinus")}
    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
    LHS "&="   Expr -> Expr {cons("AssignAnd")}
    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
    LHS "|="   Expr -> Expr {cons("AssignOr")}

    ExprName    -> LHS
    FieldAccess -> LHS
    ArrayAccess -> LHS




module languages/java-15/expressions/BinaryOperators
imports
  languages/java-15/expressions/Main
  languages/java-15/types/Main

exports
  sorts CondMid
  context-free syntax
    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}

    Expr "*"   Expr -> Expr  {left, cons("Mul")}
    Expr "/"   Expr -> Expr  {left, cons("Div")}
    Expr "%"   Expr -> Expr  {left, cons("Remain")}

    Expr "+"   Expr -> Expr  {left, cons("Plus")}
    Expr "-"   Expr -> Expr  {left, cons("Minus")}

    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}

    Expr "<"   Expr -> Expr  {left, cons("Lt")}
    Expr ">"   Expr -> Expr  {left, cons("Gt")}
    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
    Expr "=="  Expr -> Expr  {left, cons("Eq")}
    Expr "!="  Expr -> Expr  {left, cons("NotEq")}

    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}

    Expr "&" Expr -> Expr {left, cons("And")}
    Expr "^" Expr -> Expr {left, cons("ExcOr")}
    Expr "|" Expr -> Expr {left, cons("Or")}

    %% todo JFR-30
    Expr CondMid Expr -> Expr {right, cons("Cond")}
    "?" Expr ":" -> CondMid {bracket}

module languages/java-15/expressions/UnaryOperators
imports 
  languages/java-15/expressions/Main
exports
  context-free syntax
    "+" Expr -> Expr {cons("Plus")}
    "-" Expr -> Expr {cons("Minus")}

    "++" Expr -> Expr {cons("PreIncr")}
    "--" Expr -> Expr {cons("PreDecr")}

    "~" Expr -> Expr {cons("Complement")}
    "!" Expr -> Expr {cons("Not")}

    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
    "(" RefType  ")" Expr -> Expr {cons("CastRef")}

module languages/java-15/expressions/Postfix
imports 
  languages/java-15/expressions/Main

exports
  context-free syntax
    ExprName  -> Expr
    Expr "++" -> Expr {cons("PostIncr")}
    Expr "--" -> Expr {cons("PostDecr")}

module languages/java-15/expressions/MethodInvocation
imports
  languages/java-15/expressions/Main

exports
  sorts MethodSpec
  context-free syntax
    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}

                               MethodName -> MethodSpec {cons("Method")}
                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}

  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
  %% foo.bar.fred() results in a MethodName MethodSpec.
  %% (foo.bar).fred() results in the Expr. MethodSpec
  %% foo.bar.<T>fred() results in a GenericMethod
  context-free priorities
      Expr "." TypeArgs? Id -> MethodSpec
    > ExprName  -> Expr




module languages/java-15/expressions/ArrayAccess
imports
  languages/java-15/expressions/Main
exports
  sorts
    ArrayAccess
    ArraySubscript

  context-free syntax
    ArrayAccess -> Expr

    %% todo: JFR-29
    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
    "[" Expr "]" -> ArraySubscript {bracket}

    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}

module languages/java-15/expressions/FieldAccess
imports
  languages/java-15/expressions/Main

exports
  sorts FieldAccess
  context-free syntax
    FieldAccess -> Expr

  context-free syntax

                    Expr "." Id -> FieldAccess {cons("Field")}
                ExprName "." Id -> FieldAccess {reject}
                 "super" "." Id -> FieldAccess {cons("SuperField")}
    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}

module languages/java-15/expressions/ArrayCreation
imports
  languages/java-15/expressions/Main

exports
  sorts
    ArrayCreationExpr
    ArrayBaseType
    Dim
    DimExpr

  context-free syntax
    ArrayCreationExpr     -> Expr

    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}

    PrimType -> ArrayBaseType
    TypeName -> ArrayBaseType
    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}

    "[" Expr "]" -> DimExpr {cons("Dim")}
    "[" "]"      -> Dim     {cons("Dim")}

module languages/java-15/expressions/ClassInstanceCreation
imports
  languages/java-15/expressions/Main
  languages/java-15/classes/ClassDeclarations

exports
  context-free syntax

             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}

module languages/java-15/expressions/Primary
imports
  languages/java-15/lexical/literals/Main
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  %%%
   %% Section 15.8.1: Lexical Literals
   %%%
  sorts Literal
  context-free syntax
    Literal -> Expr {cons("Lit")}

    IntLiteral    -> Literal
    FloatLiteral  -> Literal
    BoolLiteral   -> Literal 
    CharLiteral   -> Literal
    StringLiteral -> Literal
    NullLiteral   -> Literal

  %%%
   %% Section 15.8.2: Class Literals
   %%%
  sorts ClassLiteral
  context-free syntax
    ClassLiteral -> Literal
    Type   "." "class" -> ClassLiteral {cons("Class")}
    "void" "." "class" -> ClassLiteral {cons("VoidClass")}

  %%%
   %% Section 15.8.3/4: (Qualified this)
   %%%
  context-free syntax
                 "this" -> Expr {cons("This")}
    TypeName "." "this" -> Expr {cons("QThis")}

  %%%
   %% Section 15.8.5: Parenthesized Expression
   %%%
  context-free syntax
    "(" Expr ")"          -> Expr {bracket}

module languages/java-15/expressions/Main
imports
  languages/java-15/expressions/Primary
  languages/java-15/expressions/ClassInstanceCreation
  languages/java-15/expressions/ArrayCreation
  languages/java-15/expressions/FieldAccess
  languages/java-15/expressions/ArrayAccess
  languages/java-15/expressions/MethodInvocation
  languages/java-15/expressions/Postfix
  languages/java-15/expressions/UnaryOperators
  languages/java-15/expressions/BinaryOperators
  languages/java-15/expressions/AssignmentOperators
  languages/java-15/expressions/Restrictions
  languages/java-15/expressions/Priorities

exports
  sorts
    Expr

module languages/java-15/statements/Main
imports
  languages/java-15/statements/Blocks
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements




module languages/java-15/arrays/Main
imports
  languages/java-15/arrays/ArrayInitializers




module languages/java-15/interfaces/Main
imports
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations




module languages/java-15/classes/Main
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations




module languages/java-15/packages/PackageDeclarations
imports
  languages/java-15/names/Main
  languages/java-15/interfaces/Annotations

exports
  sorts
    PackageDec

  context-free syntax
    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}

module languages/java-15/packages/ImportDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main

exports
  sorts
    ImportDec

  context-free syntax
    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}

module languages/java-15/interfaces/AnnotationTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    AnnoDec
    AnnoDecHead

  context-free syntax
    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}

  sorts
    AnnoElemDec
    DefaultVal

  context-free syntax
    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}

    ConstantDec  -> AnnoElemDec
    ClassDec     -> AnnoElemDec
    InterfaceDec -> AnnoElemDec
    EnumDec      -> AnnoElemDec
    AnnoDec      -> AnnoElemDec
    ";"          -> AnnoElemDec {cons("Semicolon")}

    "default" ElemVal -> DefaultVal {cons("DefaultVal")}

module languages/java-15/interfaces/AbstractMethodDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations

exports
  sorts
    AbstractMethodDec
    AbstractMethodMod

  context-free syntax
    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}

    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}

    Public   -> AbstractMethodMod
    Abstract -> AbstractMethodMod





module languages/java-15/interfaces/ConstantDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    ConstantDec
    ConstantMod

  context-free syntax
    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}

    Public -> ConstantMod
    Static -> ConstantMod
    Final  -> ConstantMod




module languages/java-15/interfaces/InterfaceDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations

exports
  sorts
    InterfaceDec
    InterfaceDecHead
    ExtendsInterfaces
    InterfaceMemberDec
    InterfaceMod

  context-free syntax
    AnnoDec -> InterfaceDec

    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}

    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}

  context-free syntax
    ConstantDec       -> InterfaceMemberDec
    AbstractMethodDec -> InterfaceMemberDec
    ClassDec          -> InterfaceMemberDec
    InterfaceDec      -> InterfaceMemberDec
    ";"               -> InterfaceMemberDec {cons("Semicolon")}

  context-free syntax
    Public         -> InterfaceMod
    Protected      -> InterfaceMod
    Private        -> InterfaceMod
    Abstract       -> InterfaceMod
    Static         -> InterfaceMod
    StrictFP       -> InterfaceMod




module languages/java-15/classes/EnumDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations

exports
  sorts
    EnumDec
    EnumDecHead
    EnumBody
    EnumConst
    EnumConstArgs
    EnumBodyDecs

  context-free syntax
    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}

    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}

    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}

    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}

    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}

module languages/java-15/classes/ConstructorDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Main
  languages/java-15/expressions/Main

exports
  sorts
    ConstrDec
    ConstrBody
    ConstrHead
    ConstrInv

  context-free syntax
    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}


    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}

             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}

  sorts ConstrMod
  context-free syntax  
    Public    -> ConstrMod
    Protected -> ConstrMod
    Private   -> ConstrMod




module languages/java-15/classes/StaticInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    StaticInit

  context-free syntax
    "static" Block -> StaticInit   {cons("StaticInit")}

module languages/java-15/classes/InstanceInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    InstanceInit

  context-free syntax
    Block -> InstanceInit {cons("InstanceInit")}

module languages/java-15/statements/Statements
imports
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Blocks
  languages/java-15/expressions/Main

exports
  sorts
    Stm

  context-free syntax
    Block      -> Stm

  %%%
   %% Section 14.6: The Empty Statement
   %%%
  context-free syntax
    ";"        -> Stm {cons("Empty")}

  %%%
   %% Section 14.7: Labeled Statements
   %%%
  context-free syntax
    Id ":" Stm -> Stm {cons("Labeled")}

  %%%
   %% Section 14.8: Expressions Statements
   %%%
  context-free syntax
    Expr ";"   -> Stm {cons("ExprStm")}

  %%%
   %% Section 14.9: The If Statement
   %%%
  context-free syntax
    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}

  %%%
   %% Section 14.10: The Assert Statement
   %%%
  context-free syntax
    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}


  %%%
   %% Section 14.11: The Switch Statement
   %%%
  sorts SwitchBlock SwitchGroup SwitchLabel
  context-free syntax
    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}

    "case" Expr ":" -> SwitchLabel {cons("Case")}
    "default"   ":" -> SwitchLabel {cons("Default")}

  %%%
   %% Section 14.12: The While Statement
   %%%
  context-free syntax
    "while" "(" Expr ")" Stm -> Stm {cons("While")}

  %%%
   %% Section 14.13: The Do Statement
   %%%
  context-free syntax
  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}


  %%%
   %% Section 14.14: The For Statement
   %%%
  context-free syntax
    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}

    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}

  %%%
   %% Section 14.15: The Break Statement
   %%%
  context-free syntax
    "break"    Id? ";"   -> Stm {cons("Break")}

  %%%
   %% Section 14.16: The Continue Statement
   %%%
  context-free syntax
    "continue" Id? ";"   -> Stm {cons("Continue")}

  %%%
   %% Section 14.17: The Return Statement
   %%%
  context-free syntax
    "return"   Expr? ";" -> Stm {cons("Return")}

  %%%
   %% Section 14.18: The Throw Statement
   %%%
  context-free syntax
    "throw"    Expr  ";" -> Stm {cons("Throw")}

  %%%
   %% Section 14.19: The Synchronized Statement
   %%%
  context-free syntax
    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}

  %%%
   %% Section 14.20: The Try Statement
   %%%
  sorts CatchClause
  context-free syntax
    "try" Block CatchClause+ -> Stm {cons("Try")}
    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}

module languages/java-15/statements/LocalVariableDeclarations
imports
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/FieldDeclarations

exports
  sorts
    LocalVarDecStm
    LocalVarDec

  context-free syntax
    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}

module languages/java-15/statements/Blocks
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements

exports
  sorts
    BlockStm
    Block

  context-free syntax
    "{" BlockStm* "}" -> Block {cons("Block")}

    LocalVarDecStm  -> BlockStm 
    ClassDec        -> BlockStm {cons("ClassDecStm")}
    Stm             -> BlockStm




module languages/java-15/classes/MethodDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/FieldDeclarations
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Blocks

exports
  sorts
    MethodDec
    MethodDecHead
    ResultType

  context-free syntax
    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}

    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}

    Type   -> ResultType
    "void" -> ResultType {cons("Void")}

  sorts FormalParam
  context-free syntax
    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}

  sorts VarMod
  context-free syntax
    Final -> VarMod

  sorts MethodMod
  context-free syntax
    Public         -> MethodMod
    Protected      -> MethodMod
    Private        -> MethodMod

    Abstract       -> MethodMod
    Static         -> MethodMod
    Final          -> MethodMod
    Synchronized   -> MethodMod
    Native         -> MethodMod
    StrictFP       -> MethodMod

  %%%
   %% Section 8.4.6: Method Throws
   %%%
  sorts
    Throws
    ExceptionType

  context-free syntax
    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
    ClassType -> ExceptionType
    %% TypeVar -> ExceptionType

  %%%
   %% Section 8.4.7: Method Body
   %%% 
  sorts MethodBody
  context-free syntax
    Block -> MethodBody
    ";"   -> MethodBody {cons("NoMethodBody")}

module languages/java-15/arrays/ArrayInitializers
imports
  languages/java-15/classes/FieldDeclarations

exports
  sorts ArrayInit
  context-free syntax
    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}

module languages/java-15/interfaces/Annotations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  sorts
    Anno
    ElemVal
    ElemValPair

  context-free syntax
    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
    "@" TypeName                            -> Anno {cons("MarkerAnno")}

  context-free syntax  
    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}

    Expr -> ElemVal
    Anno -> ElemVal

    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}

    %% Assignments are not allowed as element values.
    LHS "=" Expr -> ElemVal {reject}

module languages/java-15/classes/FieldDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/interfaces/Annotations
  languages/java-15/arrays/ArrayInitializers
  languages/java-15/expressions/Main

exports
  sorts
    FieldDec
    VarDec
    VarDecId
    Dim
    VarInit

  context-free syntax
    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}

    VarDecId             -> VarDec {cons("VarDec")}
    VarDecId "=" VarInit -> VarDec {cons("VarDec")}

    Id      -> VarDecId
    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}

    "[" "]" -> Dim {cons("Dim")}

    Expr      -> VarInit
    ArrayInit -> VarInit

  sorts FieldMod
  context-free syntax
    Public    -> FieldMod
    Protected -> FieldMod
    Private   -> FieldMod

    Static    -> FieldMod
    Final     -> FieldMod
    Transient -> FieldMod
    Volatile  -> FieldMod




module languages/java-15/classes/ClassDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/classes/FieldDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/InstanceInitializers
  languages/java-15/classes/StaticInitializers
  languages/java-15/classes/ConstructorDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    ClassDec
    ClassBody
    ClassDecHead

  context-free syntax
    EnumDec -> ClassDec

    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}

    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}

  %% 8.1.1: Class Modifiers
  sorts ClassMod
  context-free syntax
    Abstract  -> ClassMod
    Public    -> ClassMod
    Protected -> ClassMod
    Private   -> ClassMod
    Static    -> ClassMod
    Final     -> ClassMod
    StrictFP  -> ClassMod

  %% 8.1.4: Superclasses and Subclasses
  sorts Super
  context-free syntax

    "extends" ClassType -> Super {cons("SuperDec")}

  %% 8.1.5: Superinterfaces
  sorts Interfaces
  context-free syntax
    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}


  %% 8.1.6: Class Body and Member Declarations
  sorts
    ClassBodyDec
    ClassMemberDec

  context-free syntax
    ClassMemberDec -> ClassBodyDec
    InstanceInit   -> ClassBodyDec
    StaticInit     -> ClassBodyDec
    ConstrDec      -> ClassBodyDec

  context-free syntax
    FieldDec     -> ClassMemberDec
    MethodDec    -> ClassMemberDec
    ClassDec     -> ClassMemberDec
    InterfaceDec -> ClassMemberDec
    ";"          -> ClassMemberDec {cons("Semicolon")}

module languages/java-15/packages/TypeDeclarations
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    TypeDec

  context-free syntax
    ClassDec      -> TypeDec
    InterfaceDec  -> TypeDec
    ";"           -> TypeDec {cons("Semicolon")}

module languages/java-15/packages/CompilationUnits
imports
  languages/java-15/packages/PackageDeclarations
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/TypeDeclarations

exports
  sorts
    CompilationUnit

  context-free syntax
    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}

module languages/java-15/packages/Main
imports
  languages/java-15/packages/CompilationUnits
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/PackageDeclarations




module languages/java-15/names/Main
imports
  languages/java-15/lexical/Identifiers
exports
  sorts PackageName
  context-free syntax
    {Id "."}+ -> PackageName {cons("PackageName")}

  sorts
    TypeName
    ExprName
    MethodName
    PackageOrTypeName
    AmbName

  context-free syntax
    Id             -> AmbName {cons("AmbName")}
    AmbName "." Id -> AmbName {cons("AmbName")}

    Id                       -> TypeName {cons("TypeName")}
    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}

    Id             -> ExprName {cons("ExprName")}
    AmbName "." Id -> ExprName {cons("ExprName")}

    Id             -> MethodName  {cons("MethodName")}
    AmbName "." Id -> MethodName  {cons("MethodName")}

    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}

module languages/java-15/types/ParameterizedTypes
imports
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeArgs
    ActualTypeArg
    WildcardBound
    
  context-free syntax
    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}

    Type               -> ActualTypeArg
    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}

    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}

module languages/java-15/types/TypeVariables
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeParams
    TypeParam
    TypeBound
    TypeVarId
  
  context-free syntax
    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
    
    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}

    Id -> TypeVarId
    



module languages/java-15/types/ReferenceTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/types/Main  
  languages/java-15/types/ParameterizedTypes
  languages/java-15/types/TypeVariables


exports
  sorts
    RefType
    ClassOrInterfaceType
    ClassType
    InterfaceType
    TypeDecSpec
    ArrayType
    TypeVar

  context-free syntax
    ClassOrInterfaceType -> RefType
    ArrayType            -> RefType
    
    %% This production rule is highly ambiguous, since every
    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
    %% phase has to find out if a ClassOrInterfaceType is in fact
    %% a TypeVar.
    
    %% TypeVar -> RefType {avoid}

  context-free syntax
  
    %% ClassType and InterfaceType are ambiguous. We modify the
    %% production of ClassOrInterfaceType to make this ambiguity explicit.
    
    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}

    TypeName -> TypeDecSpec
    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
    
  context-free syntax    
    TypeVarId -> TypeVar {cons("TypeVar")}

  context-free syntax
    Type "[" "]" -> ArrayType  {cons("ArrayType")}

module languages/java-15/types/PrimitiveTypes
exports
  sorts
    PrimType
    NumType
    IntType  
    FloatType

  context-free syntax
    NumType   -> PrimType
    "boolean" -> PrimType {cons("Boolean")}

    IntType   -> NumType
    FloatType -> NumType

    "byte"   -> IntType   {cons("Byte")}
    "short"  -> IntType   {cons("Short")}
    "int"    -> IntType   {cons("Int")}
    "long"   -> IntType   {cons("Long")}
    "char"   -> IntType   {cons("Char")}
    "float"  -> FloatType {cons("Float")}
    "double" -> FloatType {cons("Double")}

module languages/java-15/types/Main
imports
  languages/java-15/types/PrimitiveTypes
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/types/ParameterizedTypes

exports
  sorts
    Type

  context-free syntax
    PrimType -> Type
    RefType  -> Type




module languages/java-15/lexical/literals/NullLiteral
exports
  sorts NullLiteral
  context-free syntax
    "null"  -> NullLiteral {cons("Null")}

module languages/java-15/lexical/literals/StringLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    StringLiteral
    StringPart
    StringChars
    FooStringChars

  syntax
    StringLiteral -> <StringLiteral-CF>
    
    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
    StringChars    -> StringPart {cons("Chars")}
    UnicodeEscape  -> StringPart
    EscapeSeq      -> StringPart

    <FooStringChars-LEX> -> StringChars
    ~[\"\\\n\13]+  -> <FooStringChars-LEX>

  restrictions
    StringChars -/- ~[\"\\\n\13]

module languages/java-15/lexical/literals/EscapeSequences
imports

exports
  sorts
    EscapeSeq
    NamedEscape
    OctaEscape
    LastOcta

  syntax
    OctaEscape  -> EscapeSeq
    NamedEscape -> EscapeSeq

    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}

    [0-7] -> LastOcta

  restrictions
    LastOcta -/- [0-7]

module languages/java-15/lexical/literals/CharacterLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    CharLiteral
    CharContent
    SingleChar

  syntax
    CharLiteral   -> <CharLiteral-CF>

    "'" CharContent "'" -> CharLiteral {cons("Char")}
    SingleChar    -> CharContent {cons("Single")}
    UnicodeEscape -> CharContent
    EscapeSeq     -> CharContent

    ~[\r\n\'\\] -> SingleChar




module languages/java-15/lexical/literals/BooleanLiterals
exports
  sorts
    Bool
    BoolLiteral

  context-free syntax
    Bool -> BoolLiteral {cons("Bool")}
    "true"  -> Bool {cons("True")}
    "false" -> Bool {cons("False")}

module languages/java-15/lexical/literals/FloatingPointLiterals
exports
  sorts
    FloatLiteral
    DeciFloatLiteral
    HexaFloatLiteral      
  
  context-free syntax
    DeciFloatLiteral -> FloatLiteral {cons("Float")}
    HexaFloatLiteral -> FloatLiteral {cons("Float")}

  lexical syntax
    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
    
    %% Reject plain integer literals as decimal float literals.
    %% A similar rejection for hexadecimal float literals is not
    %% required, since these always contain an exponent part.
    [0-9]+ -> DeciFloatLiteral {reject}

  lexical restrictions
    DeciFloatLiteral -/- [fFdD]
    HexaFloatLiteral -/- [fFdD]

  %%%
   %% Decimal Floating Point Numerals
   %%%
  sorts
    DeciFloatNumeral
    DeciFloatDigits
    DeciFloatExponentPart

  lexical syntax
    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral

    [0-9]* "." [0-9]* -> DeciFloatDigits
           "."        -> DeciFloatDigits {reject}
    [0-9]+            -> DeciFloatDigits

    [eE] SignedInteger -> DeciFloatExponentPart
    
    [\+\-]? [0-9]+ -> SignedInteger    

  lexical restrictions
    DeciFloatDigits  -/- [0-9]
    DeciFloatExponentPart -/- [0-9]

  %%%
   %% Hexadecimal Floating Point Literals
   %%%
  sorts
    HexaFloatNumeral
    HexaSignificand
    BinaryExponent
    SignedInteger
    
  lexical syntax
    HexaSignificand BinaryExponent -> HexaFloatNumeral

    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
    [0][xX]              "."              -> HexaSignificand {reject}

    [pP] SignedInteger -> BinaryExponent
  lexical restrictions
    HexaSignificand -/- [0-9a-fA-F]
    SignedInteger   -/- [0-9]

module languages/java-15/lexical/literals/IntegerLiterals
exports
  sorts
    IntLiteral
    DeciLiteral
    HexaLiteral
    OctaLiteral
    DeciNumeral
    HexaNumeral
    OctaNumeral

  context-free syntax
    DeciLiteral -> IntLiteral {cons("Deci")}
    HexaLiteral -> IntLiteral {cons("Hexa")}
    OctaLiteral -> IntLiteral {cons("Octa")}

  lexical syntax
    DeciNumeral [lL]? -> DeciLiteral
    HexaNumeral [lL]? -> HexaLiteral
    OctaNumeral [lL]? -> OctaLiteral

    "0" -> DeciNumeral
    [1-9][0-9]*  -> DeciNumeral
    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
    [0]     [0-7]+       -> OctaNumeral

  lexical restrictions
    DeciNumeral -/- [0-9\.fFdD]
    HexaNumeral -/- [0-9a-fA-F]
    OctaNumeral -/- [0-7]

    DeciLiteral -/- [lL]
    HexaLiteral -/- [lL]
    OctaLiteral -/- [lL]

module languages/java-15/lexical/literals/Main
imports
  languages/java-15/lexical/literals/IntegerLiterals
  languages/java-15/lexical/literals/FloatingPointLiterals
  languages/java-15/lexical/literals/BooleanLiterals  
  languages/java-15/lexical/literals/CharacterLiterals  
  languages/java-15/lexical/literals/StringLiterals
  languages/java-15/lexical/literals/NullLiteral




module languages/java-15/lexical/Modifiers
exports
  sorts
    Public
    Private
    Protected
    Abstract
    Final
    Static
    Native
    Transient
    Volatile
    Synchronized
    StrictFP
    Modifier

  context-free syntax
    "public"       -> Public       {cons("Public")}
    "private"      -> Private      {cons("Private")}
    "protected"    -> Protected    {cons("Protected")}

    "abstract"     -> Abstract     {cons("Abstract")}
    "final"        -> Final        {cons("Final")}
    "static"       -> Static       {cons("Static")}
    "native"       -> Native       {cons("Native")}
    "transient"    -> Transient    {cons("Transient")}
    "volatile"     -> Volatile     {cons("Volatile")}
    "synchronized" -> Synchronized {cons("Synchronized")}
    "strictfp"     -> StrictFP     {cons("StrictFP")}

    Public       -> Modifier
    Private      -> Modifier
    Protected    -> Modifier
    Abstract     -> Modifier
    Final        -> Modifier
    Static       -> Modifier
    Native       -> Modifier
    Transient    -> Modifier
    Volatile     -> Modifier
    Synchronized -> Modifier
    StrictFP     -> Modifier




module languages/java-15/lexical/Keywords
exports
  sorts Keyword
  lexical syntax
    "abstract"      -> Keyword
    "assert"        -> Keyword
    "boolean"       -> Keyword
    "break"         -> Keyword
    "byte"          -> Keyword
    "case"          -> Keyword
    "catch"         -> Keyword
    "char"          -> Keyword
    "class"         -> Keyword
    "const"         -> Keyword
    "continue"      -> Keyword
    "default"       -> Keyword
    "do"            -> Keyword
    "double"        -> Keyword
    "else"          -> Keyword
    "enum"          -> Keyword
    "extends"       -> Keyword
    "final"         -> Keyword
    "finally"       -> Keyword
    "float"         -> Keyword
    "for"           -> Keyword
    "goto"          -> Keyword
    "if"            -> Keyword
    "implements"    -> Keyword
    "import"        -> Keyword
    "instanceof"    -> Keyword
    "int"           -> Keyword
    "interface"     -> Keyword
    "long"          -> Keyword
    "native"        -> Keyword
    "new"           -> Keyword
    "package"       -> Keyword
    "private"       -> Keyword
    "protected"     -> Keyword
    "public"        -> Keyword
    "return"        -> Keyword
    "short"         -> Keyword
    "static"        -> Keyword
    "strictfp"      -> Keyword
    "super"         -> Keyword
    "switch"        -> Keyword
    "synchronized"  -> Keyword
    "this"          -> Keyword
    "throw"         -> Keyword
    "throws"        -> Keyword
    "transient"     -> Keyword
    "try"           -> Keyword
    "void"          -> Keyword
    "volatile"      -> Keyword
    "while"         -> Keyword

  lexical restrictions

    "abstract"
    "assert"
    "boolean" 
    "break"   
    "byte"    
    "case"    
    "catch"   
    "char"     
    "class"
    "const"    
    "continue" 
    "default"  
    "do"       
    "double"   
    "else"     
    "enum"
    "extends"  
    "final"     
    "finally"   
    "float"     
    "for"       
    "goto"       
    "if"         
    "implements" 
    "import"     
    "instanceof" 
    "int"        
    "interface"  
    "long"       
    "native"     
    "new"        
    "package"    
    "private"    
    "protected"   
    "public"       
    "return"       
    "short"        
    "static"     
    "strictfp"
    "super"        
    "switch"       
    "synchronized" 
    "this"         
    "throw"        
    "throws"       
    "transient"    
    "try"          
    "void"         
    "volatile"     
    "while"       -/- [A-Za-z0-9\_\$]

module languages/java-15/lexical/Identifiers
imports
  languages/java-15/lexical/Keywords
exports
  sorts
    Id
    ID

  context-free syntax
    ID -> Id {cons("Id")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
    
    Keyword -> ID {reject}
    "true"  -> ID {reject}
    "false" -> ID {reject}
    "null"  -> ID {reject}

  lexical restrictions
    ID -/- [a-zA-Z0-9\_\$]

module languages/java-15/lexical/Comments
imports
  languages/java-15/lexical/LineTerminators
exports
  sorts
    Comment
    EOLCommentChars
    CommentPart
    UnicodeEscape
    BlockCommentChars
    Asterisk
    EscEscChar
    EscChar

  lexical syntax
    Comment -> LAYOUT

    "//" EOLCommentChars LineTerminator -> Comment
    ~[\n\r]* -> EOLCommentChars

    "/*"  CommentPart* "*/" -> Comment
    "/**" CommentPart* "*/" -> Comment
    "/**/"                  -> Comment %% Strange javadoc comment

    BlockCommentChars -> CommentPart
    EscChar           -> CommentPart
    EscEscChar        -> CommentPart
    Asterisk          -> CommentPart
    UnicodeEscape     -> CommentPart

    ~[\*\\]+ -> BlockCommentChars

    "*"    -> Asterisk
    "\\\\" -> EscEscChar
    "\\"   -> EscChar

    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape

  lexical restrictions
    "/**"    -/- [\/]
    "/*"     -/- [\*]
    Asterisk -/- [\/]
    EscChar  -/- [\\u]

    BlockCommentChars -/- ~[\*\\]
    EOLCommentChars   -/- ~[\n\13]

  context-free restrictions
    LAYOUT?  -/- [\/].[\*]
    LAYOUT?  -/- [\/].[\/]

module languages/java-15/lexical/WhiteSpace
exports
  lexical syntax
    [\ \t\12\r\n] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\12\n\r]

module languages/java-15/lexical/LineTerminators
exports
  sorts
    LineTerminator CarriageReturn EndOfFile

  lexical syntax
    [\n]           -> LineTerminator
    [\r][\n]       -> LineTerminator
    CarriageReturn -> LineTerminator
    EndOfFile      -> LineTerminator

    [\r] -> CarriageReturn

  lexical restrictions
    CarriageReturn -/- [\n]

  %% End of file is empty.
  lexical syntax    
    -> EndOfFile

  lexical restrictions
    EndOfFile -/- ~[]

module languages/java-15/lexical/UnicodeEscapes
exports
  sorts
    UnicodeEscape

  syntax
    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}

module languages/java-15/lexical/Main
imports
  languages/java-15/lexical/UnicodeEscapes
  languages/java-15/lexical/LineTerminators
  languages/java-15/lexical/WhiteSpace
  languages/java-15/lexical/Comments
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Keywords
  languages/java-15/lexical/Modifiers
  languages/java-15/lexical/literals/Main



module languages/java-15/Main
imports
  languages/java-15/lexical/Main
  languages/java-15/types/Main
  languages/java-15/names/Main
  languages/java-15/packages/Main
  languages/java-15/classes/Main
  languages/java-15/interfaces/Main
  languages/java-15/arrays/Main
  languages/java-15/statements/Main
  languages/java-15/expressions/Main




module languages/java-15/JavaMix[Ctx0]
imports languages/java-15/Main
          [ CompilationUnit       => CompilationUnit[[Ctx0]]
            TypeDec               => TypeDec[[Ctx0]]
            ImportDec             => ImportDec[[Ctx0]]
            PackageDec            => PackageDec[[Ctx0]]
            ElemVal               => ElemVal[[Ctx0]]
            ElemValPair           => ElemValPair[[Ctx0]]
            Anno                  => Anno[[Ctx0]]
            LHS                   => LHS[[Ctx0]]
            CondMid               => CondMid[[Ctx0]]
            ArraySubscript        => ArraySubscript[[Ctx0]]
            DimExpr               => DimExpr[[Ctx0]]
            ArrayBaseType         => ArrayBaseType[[Ctx0]]
            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
            ClassMemberDec        => ClassMemberDec[[Ctx0]]
            ClassBodyDec          => ClassBodyDec[[Ctx0]]
            Interfaces            => Interfaces[[Ctx0]]
            Super                 => Super[[Ctx0]]
            ClassMod              => ClassMod[[Ctx0]]
            ClassDecHead          => ClassDecHead[[Ctx0]]
            ClassBody             => ClassBody[[Ctx0]]
            ClassDec              => ClassDec[[Ctx0]]
            InterfaceMod          => InterfaceMod[[Ctx0]]
            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
            InterfaceDec          => InterfaceDec[[Ctx0]]
            DefaultVal            => DefaultVal[[Ctx0]]
            AnnoElemDec           => AnnoElemDec[[Ctx0]]
            AnnoDecHead           => AnnoDecHead[[Ctx0]]
            AnnoDec               => AnnoDec[[Ctx0]]
            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
            ConstantMod           => ConstantMod[[Ctx0]]
            ConstantDec           => ConstantDec[[Ctx0]]
            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
            EnumConstArgs         => EnumConstArgs[[Ctx0]]
            EnumConst             => EnumConst[[Ctx0]]
            EnumBody              => EnumBody[[Ctx0]]
            EnumDecHead           => EnumDecHead[[Ctx0]]
            EnumDec               => EnumDec[[Ctx0]]
            ConstrMod             => ConstrMod[[Ctx0]]
            ConstrInv             => ConstrInv[[Ctx0]]
            ConstrBody            => ConstrBody[[Ctx0]]
            ConstrHead            => ConstrHead[[Ctx0]]
            ConstrDec             => ConstrDec[[Ctx0]]
            StaticInit            => StaticInit[[Ctx0]]
            InstanceInit          => InstanceInit[[Ctx0]]
            MethodBody            => MethodBody[[Ctx0]]
            ExceptionType         => ExceptionType[[Ctx0]]
            Throws                => Throws[[Ctx0]]
            MethodMod             => MethodMod[[Ctx0]]
            VarMod                => VarMod[[Ctx0]]
            FormalParam           => FormalParam[[Ctx0]]
            ResultType            => ResultType[[Ctx0]]
            MethodDecHead         => MethodDecHead[[Ctx0]]
            MethodDec             => MethodDec[[Ctx0]]
            BlockStm              => BlockStm[[Ctx0]]
            Block                 => Block[[Ctx0]]
            CatchClause           => CatchClause[[Ctx0]]
            SwitchLabel           => SwitchLabel[[Ctx0]]
            SwitchGroup           => SwitchGroup[[Ctx0]]
            SwitchBlock           => SwitchBlock[[Ctx0]]
            Stm                   => Stm[[Ctx0]]
            LocalVarDec           => LocalVarDec[[Ctx0]]
            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
            FieldMod              => FieldMod[[Ctx0]]
            VarInit               => VarInit[[Ctx0]]
            Dim                   => Dim[[Ctx0]]
            VarDecId              => VarDecId[[Ctx0]]
            VarDec                => VarDec[[Ctx0]]
            FieldDec              => FieldDec[[Ctx0]]
            ArrayInit             => ArrayInit[[Ctx0]]
            ClassLiteral          => ClassLiteral[[Ctx0]]
            Literal               => Literal[[Ctx0]]
            Type                  => Type[[Ctx0]]
            ArrayType             => ArrayType[[Ctx0]]
            TypeVar               => TypeVar[[Ctx0]]
            TypeDecSpec           => TypeDecSpec[[Ctx0]]
            InterfaceType         => InterfaceType[[Ctx0]]
            ClassType             => ClassType[[Ctx0]]
            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
            RefType               => RefType[[Ctx0]]
            TypeVarId             => TypeVarId[[Ctx0]]
            TypeParams            => TypeParams[[Ctx0]]
            TypeBound             => TypeBound[[Ctx0]]
            TypeParam             => TypeParam[[Ctx0]]
            WildcardBound         => WildcardBound[[Ctx0]]
            ActualTypeArg         => ActualTypeArg[[Ctx0]]
            TypeArgs              => TypeArgs[[Ctx0]]
            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
            MethodName            => MethodName[[Ctx0]]
            ExprName              => ExprName[[Ctx0]]
            TypeName              => TypeName[[Ctx0]]
            AmbName               => AmbName[[Ctx0]]
            PackageName           => PackageName[[Ctx0]]
            FloatType             => FloatType[[Ctx0]]
            IntType               => IntType[[Ctx0]]
            NumType               => NumType[[Ctx0]]
            PrimType              => PrimType[[Ctx0]]
            NullLiteral           => NullLiteral[[Ctx0]]
            FooStringChars        => FooStringChars[[Ctx0]]
            StringChars           => StringChars[[Ctx0]]
            StringPart            => StringPart[[Ctx0]]
            StringLiteral         => StringLiteral[[Ctx0]]
            SingleChar            => SingleChar[[Ctx0]]
            CharContent           => CharContent[[Ctx0]]
            CharLiteral           => CharLiteral[[Ctx0]]
            LastOcta              => LastOcta[[Ctx0]]
            OctaEscape            => OctaEscape[[Ctx0]]
            NamedEscape           => NamedEscape[[Ctx0]]
            EscapeSeq             => EscapeSeq[[Ctx0]]
            Bool                  => Bool[[Ctx0]]
            BoolLiteral           => BoolLiteral[[Ctx0]]
            BinaryExponent        => BinaryExponent[[Ctx0]]
            HexaSignificand       => HexaSignificand[[Ctx0]]
            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
            SignedInteger         => SignedInteger[[Ctx0]]
            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
            FloatLiteral          => FloatLiteral[[Ctx0]]
            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
            IntLiteral            => IntLiteral[[Ctx0]]
            OctaNumeral           => OctaNumeral[[Ctx0]]
            HexaNumeral           => HexaNumeral[[Ctx0]]
            DeciNumeral           => DeciNumeral[[Ctx0]]
            OctaLiteral           => OctaLiteral[[Ctx0]]
            HexaLiteral           => HexaLiteral[[Ctx0]]
            DeciLiteral           => DeciLiteral[[Ctx0]]
            Modifier              => Modifier[[Ctx0]]
            StrictFP              => StrictFP[[Ctx0]]
            Synchronized          => Synchronized[[Ctx0]]
            Volatile              => Volatile[[Ctx0]]
            Transient             => Transient[[Ctx0]]
            Native                => Native[[Ctx0]]
            Static                => Static[[Ctx0]]
            Final                 => Final[[Ctx0]]
            Abstract              => Abstract[[Ctx0]]
            Protected             => Protected[[Ctx0]]
            Private               => Private[[Ctx0]]
            Public                => Public[[Ctx0]]
            Id                    => Id[[Ctx0]]
            ID                    => ID[[Ctx0]]
            Keyword               => Keyword[[Ctx0]]
            ArrayAccess           => ArrayAccess[[Ctx0]]
            FieldAccess           => FieldAccess[[Ctx0]]
            MethodSpec            => MethodSpec[[Ctx0]]
            Expr                  => Expr[[Ctx0]] ]




module languages/java/JavaMix[Ctx]
imports
  languages/java-15/JavaMix[Ctx]


module languages/aspectj/JavaExtension[JavaCtx AspectCtx PointcutCtx PatternCtx]
imports
  languages/java/JavaMix[JavaCtx]
  languages/java/JavaMix[AspectCtx]
  languages/java/JavaMix[PointcutCtx]
  languages/java/JavaMix[PatternCtx]

  languages/aspectj/lexical/Keyword
  languages/aspectj/aspect/Declaration[AspectCtx JavaCtx]
  languages/aspectj/pattern/Main[PatternCtx]
  languages/aspectj/pointcut/Declaration[PointcutCtx]
  languages/aspectj/pointcut/Expression[PointcutCtx JavaCtx]

exports
  context-free syntax
    AspectDec -> TypeDec[[JavaCtx]]

    AspectDec   -> ClassMemberDec[[JavaCtx]]
    PointcutDec -> ClassMemberDec[[JavaCtx]]

    AspectDec   -> InterfaceMemberDec[[JavaCtx]]
    PointcutDec -> InterfaceMemberDec[[JavaCtx]]


module languages/aspectj/abc/Main[JavaCtx AspectCtx PointcutCtx PatternCtx]
imports
  languages/aspectj/JavaExtension[JavaCtx AspectCtx PointcutCtx PatternCtx]
  languages/aspectj/abc/Keyword[JavaCtx AspectCtx PointcutCtx PatternCtx]


module aspectj-abc
imports
  languages/aspectj/abc/Main[JavaTheCtx AspectTheCtx PointcutTheCtx PatternTheCtx]

exports
  sorts JavaTheCtx AspectTheCtx PointcutTheCtx PatternTheCtx
  context-free start-symbols JavaCtxCompilationUnit
  context-free syntax
    CompilationUnit[[JavaTheCtx]] -> JavaCtxCompilationUnit
